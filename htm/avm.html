<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="aybehrouz" />
  <title>The Algorand Virtual Machine</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">The Algorand Virtual Machine</h1>
<p class="author">aybehrouz</p>
<p class="date">January 2021</p>
</header>
<h1 id="ch:specification">Specification</h1>
<h2 id="sec:introduction">Introduction</h2>
<p>The Algorand Virtual Machine (AVM) is an abstract computing machine for executing Algorand’s smart contracts. It is designed in a way that it could be efficiently implemented in either hardware or software.</p>
<h2 id="sec:the-structure-of-the-algorand-virtual-machine">The Structure of the Algorand Virtual Machine</h2>
<p>...</p>
<h3 id="subsec:data-types">Data Types</h3>
<p>The Algorand Virtual Machine expects that all type checking is done prior to run time, typically by a compiler, and does not have to be done by the Algorand Virtual Machine itself.</p>
<p>The instruction set of the Algorand Virtual Machine distinguishes its operand types using instructions intended to operate on values of specific types. For instance, <code>iadd</code> assumes that its operands are two 64-bit integers.</p>
<h3 id="subsec:the-pc-register">The <code>PC</code> Register</h3>
<p>...</p>
<h3 id="subsec:call-stack">Call Stack</h3>
<p>A call stack contains the information that is needed for restoring the state of the invoker of a method.</p>
<h3 id="subsec:memory-unit">Memory Unit</h3>
<p>The Algorand Virtual Machine has a byte addressable memory which is divided into separate segments. Every segment belongs to a smart contract that has a unique <code>applicationID</code>. The AVM always has a single working memory segment and memory locations outside its current working segment can not be accessed. The only instructions which can change the current working segment are <code>invoke_external</code>, <code>athrow</code> and return instructions.</p>
<p>Every smart contract has its own memory segment. Hence, there is no way for a smart contract to access another smart contract’s memory. Interaction between smart contracts is done using <code>invoke_external</code> instruction, and A smart contract can invoke methods of another smart contract by this instruction.</p>
<p>A memory segment consists of five data areas:</p>
<ul>
<li><p>Code Area</p></li>
<li><p>Constant Area</p></li>
<li><p>Local Frame</p></li>
<li><p>Operand Stack</p></li>
<li><p>Heap</p></li>
</ul>
<p>All data areas except operand stack, have their own address space which starts from 0. Operand stack is a last-in-first-out (LIFO) stack and is not addressable. Every memory access instruction operates on its specific data areas.</p>
<h4 id="code-area">Code Area</h4>
<p>The code area of a segment contains the byte-code of the smart contract which owns that segment. The AVM has no instructions for manipulating the code area. <strong>Installing, removing and updating smart contracts need to be done externally.</strong></p>
<h4 id="constant-area">Constant Area</h4>
<p>The constant area of a segment contains several kinds of constants, ranging from user defined constants to method address tables. A method address table stores method locations in the code area and their access type. The access type of a method can be either <code>public</code> or <code>private</code>. The AVM has no instructions for modifying the constant area.</p>
<p><em>Only public methods can be invoked by <code>invoke_external</code> instruction.</em></p>
<h4 id="local-frame">Local Frame</h4>
<p>A local frame is used to store methods parameters and local variables. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes, whether the completion is normal or abrupt.</p>
<h4 id="operand-stack">Operand Stack</h4>
<p>Every time a local frame is created, a corresponding empty last-in-first-out (LIFO) stack is created too. AVM instructions take operands from the operand stack, operate on them, and push the result back onto the operand stack. An operand stack is destroyed when its owner method completes, whether that completion is normal or abrupt.</p>
<h4 id="heap">Heap</h4>
<p>The heap of a segment is a persistent memory area which is divided into pages. Each page can be referenced by an index that starts from 0. Memory locations inside every page have a separate address space that starts from 0. In other words, the address of every memory location inside a heap is a pair of indices: <code>(pageIndex, offset) </code>. Pages of a heap do not need to be equally sized.</p>
<p><em>The reason behind this paged design is that the heap is usually persisted using a block device. A heap with a paged structure could expose the underlying block based nature of the persistence layer to the application layer. In this way, the compiler or the programmer could better optimize the code for the persistence layer.</em></p>
<h2 id="subsec:instruction-set-summary">Instruction Set Summary</h2>
<p>An Algorand Virtual Machine instruction consists of a <strong>one-byte</strong> opcode specifying the operation to be performed, followed by zero or more operands supplying arguments or data that are used by the operation. <strong>The number and size of the operands are determined solely by the opcode.</strong></p>
<h3 id="subsec:method-invocation">Method Invocation</h3>
<p>The Algorand Virtual Machine has three types of method invocation:</p>
<ul>
<li><p><code>invoke_internal</code> invokes a method from the current running smart contract.</p></li>
<li><p><code>invoke_external</code> invokes a <code>public</code> method from another smart contract. It will change the current memory segment to the segment of the invoked smart contract.</p></li>
<li><p><code>invoke_native</code> invokes a method that is not hosted by the Algorand virtual machine. By this instruction, high performance native methods of a hosting machine could become available to AVM smart contracts.</p></li>
</ul>
<p><em>In the future, we may need to add special instructions for invoking interface and virtual methods...</em></p>
<p>Each time a method is invoked a new local frame and operand stack is created. The Algorand Virtual Machine uses local frames to pass parameters on method invocation. On method invocation, any parameters are passed in consecutive local variables stored in the method’s local frame starting from local variable 0. The invoker of a method writes the parameters in the local frame of the invoked method using <code>arg</code> instructions.</p>
<h4 id="exceptions">Exceptions</h4>
<p>An exception is thrown programmatically using the <code>athrow</code> instruction. Exceptions can also be thrown by various Algorand Virtual Machine instructions if they detect an abnormal condition. Some exceptions are not catchable and will always abort the execution of the smart contract.</p>
<h4 id="method-invocation-completion">Method Invocation Completion</h4>
<p>A method invocation completes normally if that invocation does not cause an exception to be thrown, either directly from the AVM or as a result of executing an explicit throw statement. If the invocation of the current method completes normally, then a value may be returned to the invoking method. This occurs when the invoked method executes one of the return instructions, the choice of which must be appropriate for the type of the value being returned (if any). Execution then continues normally in the invoking method’s local frame with the returned value (if any) pushed onto the operand stack.</p>
<p>A method invocation completes abruptly if an exceptions is thrown and is not caught by the current method. A method invocation that completes abruptly never returns a value to its invoker.</p>
<p>When a method completes, whether normally or abruptly, the call stack is used to restore the state of the invoker, including its local frame and operand stack, with the <code>PC</code> register appropriately restored and incremented to skip past the method invocation instruction. If the invoker was another smart contract, i.e. the invocation was made by an <code>invoke_external</code> instruction, the current memory segment will be changed to the invoker’s segment.</p>
<p>A thrown exception causes methods in the call stack to complete <strong>abruptly</strong> one by one, as long as the <code>PC</code> register is not pointing to a <code>catch</code> instruction. The <code>catch</code> instruction acts like a branch instruction that branches only if an exception is caught. <strong>When an external method invocation completes abruptly, before changing the current segment, all changes made to the heap area will be rolled back.</strong></p>
<p><em>By using the <code>athrow</code> instruction properly, a programmer can make any method act like an atomic operation.</em></p>
<h4 id="authorizing-operations">Authorizing Operations</h4>
<p>In blockchain applications, we usually need to authorize certain operations. For example, for sending an asset from a user to another user, first we need to make sure that the sender has authorized this operation. The Algorand virtual machine has no built in mechanism for authorizing operations, but it provides a rich set of cryptographic instructions for validating signatures and cryptographic entities. By using these instructions and passing signatures as parameters to methods a programmer can implement the required logic for authorizing any operation.</p>
<p><em>The Algorand virtual machine has no instructions for issuing cryptographic signatures.</em></p>
<p>In addition to signatures, a method can verify its invoker by using <code>get_parent</code> instruction. This instruction gets the <code>applicationID</code> of the smart contract that is one level deeper than the current smart contract in the call stack. In other words, it gives the smart contract that has invoked the current smart contract. (if any)</p>
<h4 id="heap-allocation-instructions">Heap Allocation Instructions</h4>
<p>...</p>
<h1 id="ch:implementation">Implementation</h1>
<h2 id="sec:persistence">Persistence</h2>
<p>For implementing the persistence layer of the AVM, we assume that we have access to an updatable zero-knowledge elementary database (ZK-EDB) with the following properties:</p>
<ul>
<li><p>The ZK-EDB contains a mapping from a set of keys to a set of values.</p></li>
<li><p>Every state of the database has a commitment <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p></li>
<li><p>The ZK-EDB has a method <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>D</mi><mo>,</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(D, p) = get(x)</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is a key and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math> is the associated value with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> is a proof.</p></li>
<li><p>A user can use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> to verify that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math> is really associated with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math> is not altered. Consequently, a user who can obtain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> from a trusted source does not need to trust the ZK-EDB.</p></li>
<li><p>Having <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> a user can compute the commitment <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">C&#39;</annotation></semantics></math> for the database in which <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">D&#39;</annotation></semantics></math> is associated with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> instead of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>.</p></li>
</ul>
<p>We use a ZK-EDB for storing the AVM heap. We include the commitment of the current state of this DB in every block of the Algorand blockchain, so ZK-EDB servers need not be trusted servers.</p>
<p>Every page of AVM heap will be stored with a key of the form: <code>applicationID|pageIndex</code> (the <code>|</code> operator concatenates two numbers). Nodes do not keep a full copy of the AVM heap and for validating block certificates or emulating the AVM ( i.e. validating transactions) they need to connect to a ZK-EDB and retrieve the required pages of AVM heap. For better performance, nodes keep a cache of heap pages to reduce the amount of ZK-EDB access.</p>
<p>We also use a ZK-EDB for storing the code area of each segment, and we include the commitment of this DB in every block. Every code area will be divided into blocks and every block will be stored in the DB with <code>applicationID|blockID</code> as its key. Like heap pages, nodes keep a cache of code area blocks.</p>
<p><em>Unlike heap pages, the AVM is not aware of different blocks of the code area.</em></p>
<h2 id="sec:transactions">Transactions</h2>
<p>Algorand has four types of transaction:</p>
<ul>
<li><p><code>avmCall</code> essentially is an <code>invoke_external</code> instruction that invokes a method from an AVM smart contract. Users interact with AVM smart contracts using these transactions. Transferring all assets, including ALGOs, is done by these transactions.</p></li>
<li><p><code>installApp</code> installs an AVM smart contract and determines the update policy of the smart contract: if the contract is updatable or not, the accounts that can update or uninstall the contract, and so on.</p></li>
<li><p><code>unInstallApp</code> removes an AVM smart contract.</p></li>
<li><p><code>updateApp</code> updates an AVM smart contract.</p></li>
</ul>
<p>All types of Algorand transactions contain an <code>invoke_external</code> instruction which calls a special method from ALGO smart contract that transfers the proposed fee of the transaction in ALGOs from a sender account to the fee sink accounts.</p>
<p>Every transaction is required to exactly specify what heap pages or code area blocks it will access. This enables validators to start retrieving the required memory blocks from available ZK-EDB servers as soon as they see a transaction, and they won’t need to wait for receiving the new proposed block. A transaction that tries to access a memory block that is not included in its access lists, will be rejected. Users could use smart contract oracles to predict the list of memory blocks their transactions need. See Section <a href="#sec:smart-contract-oracle" data-reference-type="ref" data-reference="sec:smart-contract-oracle">2.7</a> for more details.</p>
<h2 id="sec:blockchain">Blockchain</h2>
<p>Every block of the Algorand blockchain corresponds to a set of transactions. We store the commitment of this transaction set in every block, but we don’t keep the set itself. To be able to detect replay attacks, we require every signature that a user creates to have a nonce. This nonce consists of the issuance round of the signature and a sequence number: <code>(issuance, sequence)</code>. When a user creates more than one signature in a round, he must sequence his signatures starting from 0 (i.e. the sequence number restarts from 0 in every round). We define a maximum lifetime for signatures, so a signature is invalid if <code>currentRound - issuance &gt; maxLifeTime</code> or if a signature of the same user with a bigger or equal nonce is already used (i.e . is recorded in the blockchain). A nonce is bigger than another nonce if it has an older issuance. If two nonces have an equal issuance, the nonce with the bigger sequence number will be considered bigger.</p>
<p>To be able to detect invalid signatures, we keep the maximum nonce of used digital signatures per user. When the difference between <code>issuance</code> component of this nonce and the current round becomes bigger than the maximum allowed lifetime of a signature, this information can be safely deleted. <strong>As a result, we will not have the problem of " unremovable empty accounts" like Ethereum.</strong></p>
<p>The only information that Algorand nodes are required to store is <strong>the most recent block</strong> of the Algorand blockchain. Every block of the Algorand blockchain contains the following information:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Block</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">commitment to the ZK-EDB storing heap pages</td>
</tr>
<tr class="even">
<td style="text-align: center;">commitment to the ZK-EDB storing code areas</td>
</tr>
<tr class="odd">
<td style="text-align: center;">commitment to the set of transactions</td>
</tr>
<tr class="even">
<td style="text-align: center;">previous block hash</td>
</tr>
<tr class="odd">
<td style="text-align: center;">random seed</td>
</tr>
</tbody>
</table>
<p>For confirming a new block, nodes that are not validators only need to verify the block certificate. For verifying a block certificate, a node needs to know the ALGO balances of validators, but it doesn’t need to emulate the AVM execution.</p>
<p>On the other hand, nodes that are chosen to be validators, for validating a new block, need to emulate the execution of the Algorand virtual machine. To do so, first they retrieve all heap pages and code area blocks they need from available ZK-EDBs. Then, they emulate the execution of AVM instructions and validate all the transactions included in the new block. This will modify some pages of the AVM memory, so they update the ZK-EDB commitments based on the modified pages and verify the commitments included in the new block. Validators also calculate and verify the commitment to the new block’s transaction set.</p>
<p><em>Validators do not need to write the modified pages back to ZK-EDB servers. ZK-EDBs will receive the new block, and they will update their database by emulating the AVM execution.</em></p>
<h2 id="incentive-mechanism">Incentive mechanism</h2>
<h3 id="subsec:transaction-fee">Transaction Fee</h3>
<p>Every transaction in the Algorand blockchain starts with an <code>invoke_external</code> instruction which calls a special method from ALGO smart contract. This method will transfer the proposed fee of the transaction in ALGOs from a sender account to the fee sink accounts. Algorand has two fee sink accounts: <code>execFeeSink</code> collects execution fees and <code>dbFeeSink</code> collects fees for ZK-EDBs. The Protocol decides how to distribute the transaction fee between these two fee sink accounts.</p>
<p>When a block is added to the blockchain, the proposer of that block will receive a share of the block fees. Consequently, a block proposer is always incentivized to include more transactions in his block. However, if he puts too many transactions in his block and the validation of the block becomes too difficult, some validators may not be able to validate all transactions on time. If a validator can not validate a block in the required time, he will consider the block invalid. So, when a proposed block contains too many transactions, the network may reach consensus on another block, and the proposer of that block will not receive any fees. As a result, a proposer is incentivized to use network transaction capacity optimally.</p>
<p>On the other hand, we believe that the proposer does not have enough incentives for optimizing the storage size of the transaction set. Therefore, we require that <strong>the size of the transaction set of every block in bytes be lower than a certain threshold.</strong></p>
<p>Validators need to spend resources for validating transactions. When a validator starts the emulation of the AVM to validate a transaction, solely from the code he can’t predict the time the execution will finish. This will give an adversary an opportunity to attack the network by broadcasting transactions that never ends. Since, validators can not finish the execution of these transactions, the network will not be able to charge the attacker any fees, and he would be able to waste validators resources for free.</p>
<p>To mitigate this problem, we require that every transaction specify a cap for all the resources it needs. This will include memory, network and processor related resources. Also, the protocol defines an execution cost for every AVM instruction reflecting the amount of resources its emulation needs. This will define a standard way for measuring the execution cost of any <code>avmCall</code> transaction. Every <code>avmCall</code> transaction is required to specify a maximum execution cost. If during emulation it reaches this maximum cost, the transaction will be considered failed and the network can receive the proposed fee of that transaction.</p>
<p>Every <code>avmCall</code> transaction is required to provide the following information as an upper bound for the resources it needs:</p>
<ul>
<li><p>Execution cost</p></li>
<li><p>A list of heap/code-area pages for reading</p></li>
<li><p>A list of heap pages for writing</p></li>
<li><p>A list of heap pages it will deallocate</p></li>
<li><p>Number and size of heap pages it will allocate</p></li>
</ul>
<p>If a transaction tries to violate any of these predefined limitations, for example, if it tries to read a memory location that is not included in its reading list, it will be considered failed and the network can receive the proposed fee of that transaction.</p>
<p><em>A transaction always pays all of its proposed fee, no matter how much of its predefined resources were not used in the final emulation.</em></p>
<h3 id="subsec:zk-edb-servers">ZK-EDB Servers</h3>
<p>The incentive mechanism for ZK-EDB servers should have the following properties:</p>
<ul>
<li><p>It incentivizes storing all memory blocks, whether a heap page or a code area block, and not only those that are used more frequently.</p></li>
<li><p>It incentivizes the ZK-EDB servers to actively provide the required memory blocks for validators.</p></li>
<li><p>Making more accounts will not provide any advantages for a ZK-EDB server.</p></li>
</ul>
<p>For our incentive mechanism, we require that every time a validator receives a memory block from a ZK-EDB, after validating the data, he give a receipt to the ZK-EDB. In this receipt the validator signs the following information:</p>
<ul>
<li><p><code>ownerAddr</code> the ALGO address of the ZK-EDB.</p></li>
<li><p><code>receivedBlockID</code> the ID of the received memory block.</p></li>
<li><p><code>round</code> the current round number.</p></li>
</ul>
<p><em>In a round, an honest validator never gives a receipt for an identical memory block to two different ZK-EDBs.</em></p>
<p>To incentivize ZK-EDB servers, every round a lottery will be held and a predefined amount of ALGOs from <code>dbFeeSink</code> account will be distributed between winners as a prize. This prize will be divided equally between all the <em>winning tickets</em> of the lottery.</p>
<p><em>One ZK-EDB server could own multiple winning tickets in a round.</em></p>
<p>To run this lottery, In every round, based on the current block seed, a collection of <em>valid</em> receipts will be selected randomly as the <em>winning</em> receipts. A receipt is <em>valid</em> in the round <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math> if:</p>
<ul>
<li><p>The signer was a validator in the round <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r - 1</annotation></semantics></math> and voted for the agreed-upon block.</p></li>
<li><p>The data block in the receipt was needed for validating the <strong>previous</strong> block.</p></li>
<li><p>The receipt round number is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r - 1</annotation></semantics></math>.</p></li>
<li><p>The signer did not sign a receipt for the same data block for two different ZK-EDBs in the previous round.</p></li>
</ul>
<p>For selecting the winning receipts we could use a random generator:</p>
<pre><code>        if random(seed|validatorPK|receivedBlockID) &lt; winProbability
            the receipt issued by validatorPK for receivedBlockID is a winner</code></pre>
<ul>
<li><p><code>random()</code> produces uniform random numbers between 0 and 1, using its input argument as a seed.</p></li>
<li><p><code>validatorPK</code> is the public key of the signer of the receipt.</p></li>
<li><p><code>receivedBlockID</code> is the ID of the memory block that the receipt was issued for.</p></li>
<li><p><code>winProbability</code> is the probability of winning in every round.</p></li>
<li><p><code>seed</code> is the current block seed.</p></li>
<li><p><code>|</code> is a concatenation operator.</p></li>
</ul>
<p><em>The winners of the lottery were validators one round before the lottery round.</em></p>
<p>Also, based on the current block seed, a random memory block, whether a heap page or a code area block, is selected as the challenge of the round. A ZK-EDB that owns a winning receipt needs to broadcast a <em>winning ticket</em> to claim his prize. The winning ticket consists of a winning receipt and a <em>solution</em> to the round challenge. Solving a round challenge requires the content of the memory block which was selected as the round challenge. This will encourage ZK-EDBs to store all memory blocks.</p>
<p>A possible choice for the challenge solution could be the cryptographic hash of the content of the challenge memory block combined with the ZK-EDB ALGO address: <code>hash(challenge.content|ownerAddr)</code></p>
<p>The winning tickets of the lottery of the round <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math> need to be included in the block of the round <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>, otherwise they will be considered expired. Validation and prize distribution for the winning tickets of the round <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math> will be done in the round <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r + 1</annotation></semantics></math>. This way, <strong>the content of the challenge memory block could be kept secret during the lottery round.</strong> Every winning ticket will get an equal share of the lottery prize.</p>
<h3 id="subsec:memory-allocation-and-de-allocation">Memory Allocation and De-allocation</h3>
<p>Every k round the protocol chooses a price per byte for the AVM memory. When a smart contract executes a heap allocation instruction, the protocol will automatically deduce the cost of the allocated memory from the ALGO address of the smart contract.</p>
<p>To determine the price of AVM memory, Every k round, the protocol calculates <code>dbFee</code> and <code>memTraffic</code> values. <code>dbFee</code> is the aggregate amount of collected database fees and <code>memTraffic</code> is the total memory traffic of the system. For calculating the memory traffic of the system the protocol considers the total size of all memory pages that were accessed for either reading or writing during some time. These two values will be calculated for the last k rounds and the price per byte of the AVM memory will be a linear function of <code>dbFee/memTraffic</code></p>
<p>When a smart contract executes a heap de-allocation instruction, the protocol will refund the cost of de-allocated memory to the smart contract. Here, the current price of AVM memory does not matter and the protocol calculates the refunded amount based on the average price the smart had paid for that allocated memory. This will prevent smart contracts from profit taking by trading memory with the protocol.</p>
<h2 id="sec:concurrency">Concurrency</h2>
<p>Every block of the Algorand blockchain contains a list of transactions. This list is an ordered list and the effect of its contained transactions must be applied to the AVM state sequentially as they appear in the ordered list. The ordering of transactions in a block is solely chosen by the block proposer.</p>
<p><em>Users should not have any assumption about the ordering of transactions in a block.</em></p>
<p>The fact that block transactions constitute a sequential list, does not mean they can not be validated concurrently. Many transactions are actually independent and the order of their execution does not matter. These transactions can be safely validated in parallel by validators.</p>
<p>A transaction can change the AVM state by modifying either the code area or the AVM heap. In Algorand, all transactions declare the list of memory blocks they want to read or write. This will enable us to determine the independent sets of transactions which can be validated in parallel. To do so, we define the <em>memory dependency graph</em> as follows:</p>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math> is an undirected graph.</p></li>
<li><p>Every vertex in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math> corresponds to a transaction.</p></li>
<li><p>Vertices <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math> are adjacent in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math> if and only if u has a memory block <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> in its writing list and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math> has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> in either its writing list or reading list.</p></li>
</ul>
<p>If we consider a proper vertex coloring of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>, every color class will give us an independent set of transactions that can be validated concurrently. To achieve the highest parallelization, we need to color <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math> with minimum number of colors. Thus, the chromatic number of the memory dependency graph shows how good a transaction set could be run concurrently.</p>
<p>Graph coloring is computationally NP-hard. However, in our use case we don’t need to necessarily find an optimal solution. An approximate greedy algorithm will perform well enough in most circumstances. The block proposer is responsible for solving the graph coloring problem anda proposed block must determine the independent sets of transactions which can be run in parallel safely. Since with better parallelization a block can contain more transactions, a proposer is incentivized enough to find a good graph coloring.</p>
<h2 id="sec:consensus">Consensus</h2>
<h3 id="subsec:estimating-a-user&#39;s-stake">Estimating A User’s Stake</h3>
<p>In a proof of stake system the influence of a user in the consensus protocol should be proportional to the amount of stake the user has in the system. Conventionally in these systems, for estimating a user’s stake, we use the amount of native system tokens the user is holding. Unfortunately, one problem with this approach is that a strong attacker may be able to obtain a considerable amount of system tokens, for example by borrowing from a DEFI application, and use this stake to attack the system.</p>
<p>To mitigate this problem, for calculating a user’s stake at the time step <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>, instead of using the raw ALGO balance, we use the minimum of a <em>trust value</em> the system has calculated for the user and the user’s ALGO balance:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mrow><mi>u</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>=</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>u</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>T</mi><mi>r</mi><mi>u</mi><mi>s</mi><msub><mi>t</mi><mrow><mi>u</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Stake_{u,t} = \min (Balance_{u,t}, Trust_{u,t})</annotation></semantics></math></p>
<p>For estimating the value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>s</mi><msub><mi>t</mi><mrow><mi>u</mi><mo>,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Trust_{u,t}</annotation></semantics></math> we use the following formula:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>s</mi><msub><mi>t</mi><mrow><mi>u</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>=</mo><mo>max</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>M</mi><mrow><mi>u</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>β</mi><mi>B</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>u</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Trust_{u,t} = \max (M_{u,t}, \beta Balance_{u,t})</annotation></semantics></math></p>
<p>Where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mrow><mi>u</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">M_{u,t}</annotation></semantics></math> is the exponential moving average of the ALGO balance of the user <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math> at the time step <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math> is a constant between <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math> determining the minimum trust value of a user.</p>
<p>The agreement protocol, at the time step <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>, will use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>u</mi></msub><mi>S</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mrow><mi>u</mi><mo>,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\sum_{u}Stake_{u,t}</annotation></semantics></math> to determine the required number of votes for the confirmation of a block. At the start of the agreement protocol, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math> is initialized to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>. If after confirming a block we have:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>∑</mo><mi>u</mi></munder><mi>S</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mi>u</mi></msub><mo>&lt;</mo><mi>γ</mi><munder><mo>∑</mo><mi>u</mi></munder><mi>B</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>c</mi><msub><mi>e</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{u}Stake_u &lt; \gamma \sum_{u} Balance_u</annotation></semantics></math></p>
<p>The protocol will increase the value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math> to make sure that the total stake of the system goes high enough. If after confirming a block we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\beta &gt; 0</annotation></semantics></math> and:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>∑</mo><mi>u</mi></munder><mi>S</mi><mi>t</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mi>u</mi></msub><mo>&gt;</mo><mi>λ</mi><munder><mo>∑</mo><mi>u</mi></munder><mi>B</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>c</mi><msub><mi>e</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{u}Stake_u &gt; \lambda \sum_{u} Balance_u</annotation></semantics></math></p>
<p>The protocol will decrease the value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math> until it eventually reaches <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math> again.</p>
<p>In our system a user who held ALGOs and participated in the consensus for a long time is more trusted than a user with a higher balance whose balance has increased recently. An attacker who has obtained a large amount of ALGOs, also needs to hold them for a long period of time before being able to attack our system.</p>
<p>For calculating the exponential moving average of a time series at the time step <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>, we can use the following recursive formula:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>t</mi></msub><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false" form="postfix">)</mo><msub><mi>M</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>α</mi><msub><mi>X</mi><mi>t</mi></msub><mo>=</mo><msub><mi>M</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>α</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>t</mi></msub><mo>−</mo><msub><mi>M</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">M_t = (1 - \alpha) M_{t-1} + \alpha X_t = M_{t-1} + \alpha (X_t - M_{t-1})</annotation></semantics></math></p>
<p>Where:</p>
<ul>
<li><p>The coefficient <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> is a constant smoothing factor between <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math> and<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math> which represents the degree of weighting decrease, A higher <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> discounts older observations faster.</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>t</mi></msub><annotation encoding="application/x-tex">X_t</annotation></semantics></math> is the value of the time series at the time step <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>t</mi></msub><annotation encoding="application/x-tex">M_t</annotation></semantics></math> is the value of the EMA at the time step <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.</p></li>
</ul>
<p>Usually an account balance will not change in every time step, and we can use older values of EMA for calculating <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>t</mi></msub><annotation encoding="application/x-tex">M_t</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>t</mi></msub><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi>t</mi><mo>−</mo><mi>k</mi></mrow></msup><msub><mi>M</mi><mi>k</mi></msub><mo>+</mo><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo>−</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi>t</mi><mo>−</mo><mi>k</mi></mrow></msup><mo stretchy="false" form="postfix">]</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">M_t = (1 - \alpha)^{t-k}M_k + [1 - (1 - \alpha)^{t - k}]X</annotation></semantics></math></p>
<p>Where:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><msub><mi>X</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>X</mi><mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><mi>…</mi><mo>=</mo><msub><mi>X</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">X = X_{k+1} = X_{k+2} = \dots = X_t</annotation></semantics></math></p>
<p>When <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">|</mo><mi>n</mi><mi>x</mi><mo stretchy="false" form="prefix">|</mo><mo>≪</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|nx| \ll 1</annotation></semantics></math> we can use the binomial approximation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><msup><mo stretchy="false" form="postfix">)</mo><mi>n</mi></msup><mo>≈</mo><mn>1</mn><mo>+</mo><mi>n</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">(1 + x)^n \approx 1 + nx</annotation></semantics></math> to further simplify this formula:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>t</mi></msub><mo>=</mo><msub><mi>M</mi><mi>k</mi></msub><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo>−</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mi>α</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>−</mo><msub><mi>M</mi><mi>k</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">M_t = M_k + (t - k) \alpha (X - M_k)</annotation></semantics></math></p>
<p>For choosing the value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> we can consider the number of time steps that the trust value of a user needs for reaching a specified fraction of his account balance. We know that for large <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo stretchy="false" form="prefix">|</mo><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|x| &lt; 1</annotation></semantics></math> we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><msup><mo stretchy="false" form="postfix">)</mo><mi>n</mi></msup><mo>≈</mo><msup><mi>e</mi><mrow><mi>n</mi><mi>x</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(1 + x)^n \approx e^{nx}</annotation></semantics></math>, so by letting <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>k</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">M_k = 0</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>t</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n = t - k</annotation></semantics></math> we can write:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mo>−</mo><mfrac><mrow><mo>ln</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mfrac><msub><mi>M</mi><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msub><mi>X</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\alpha =- \frac{\ln\left(1 - \frac{M_{n+k}}{X}\right)}{n}</annotation></semantics></math></p>
<p>The value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> for a desired configuration can be calculated by this equation. For instance, we could calculate the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> for a relatively good configuration in which <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msub><mo>=</mo><mn>0.8</mn><mi>X</mi></mrow><annotation encoding="application/x-tex">M_{n+k} = 0.8X</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> equals to the number of time steps of 10 years.</p>
<h2 id="sec:smart-contract-oracle">Smart Contract Oracle</h2>
<p>A smart contract oracle is a full AVM emulator that keeps a full local copy of AVM memory and can emulate AVM execution without accessing a ZK-EDB. Smart contract oracles can be used for reporting useful information about <code>avmCall</code> transactions such as accessed AVM heap pages or code area blocks, exact amount of execution cost, and soon.</p>
</body>
</html>
