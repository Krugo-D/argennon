%! Author = aybehrouz

\section{Applications}\label{sec:applications}

An Argennon application or a smart contract is a collection of method bytecodes and heap chunks that are stored in
the AVM storage, identified by a unique application identifier. An application identifier, \texttt{applicationID}, is
a unique prefix code generated by the \emph{applications} prefix tree. (See Section~\ref{sec:identifiers}.)

An application identifier can
be considered as the address of an application and has the following standard symbolic representation:
\begin{verbatim}
<application-id> ::= <decimal-prefix-code>
<decimal-prefix-code> ::= <dec-num>"."<decimal-prefix-code> | <dec-num>
\end{verbatim}
where \texttt{<dec-num>} is a normal decimal number between $0$ and $255$.

For example \texttt{21.255.37}, \texttt{0} and \texttt{1.0.0.0.0}, are valid application addresses.

Argennon has two special smart contracts: the \emph{root smart contract}, also called the \emph{root application}, and
the \emph{ARG smart contract}, which is also called the Argennon smart contract or the \emph{ARG application}.

\subsection{The Root Application}\label{subsec:the-root-app}

The root application or the root smart contract, with \texttt{applicationID = 0}, is a privileged smart contract
responsible for installation/uninstallation of other smart contracts. The Argennon root smart contract
performs three main operations:

\begin{itemize}
    \item Installation of AVM smart contracts and determining the update policy of a smart
    contract: if the contract is updatable or not, which accounts can update or uninstall the contract, and so
    on.
    \item Removing AVM smart contracts.
    \item Updating an AVM smart contract (if allowed).
\end{itemize}

The root smart contract is a mutable smart contract and can be updated by the Argennon governance system.
(See Section~\ref{sec:adags})

\subsection{The ARG Application}\label{subsec:the-arg-app}

The ARG application or the ARG smart contract,
with \texttt{applicationID = 1}, controls the ARG token, the main
currency of the Argennon blockchain. This smart contract also manages a database of public keys and
handles signature verification.

The ARG smart contract is a mutable smart contract and can be updated by the Argennon governance system.


\section{Accounts}\label{sec:accounts}

Argennon accounts are entities defined inside the ARG smart contract.
Every Argennon account is uniquely identified by a prefix code generated using \emph{accounts} prefix
tree. (See Section~\ref{sec:identifiers}) An account
identifier can be considered as the address of an account and has the following standard symbolic representation:
\begin{verbatim}
<account-id> ::= <hex-prefix-code>
<hex-prefix-code> ::= "0x"<hex-num>"."<hex-prefix-code> | "0x"<hex-num>
\end{verbatim}
where \texttt{<hex-num>} is a hexadecimal number between $0$ and $255$, using lower case
letters \texttt{[a-f]} for showing digits greater than $9$.

For example \texttt{0x24.0xff.0xda}, \texttt{0x0} and \texttt{0x3.0xa0.0x0.0x0}, are valid standard symbolic
representations of account addresses.

A new account can be created by invoking \texttt{createAccount} method from the Argennon smart contract. For creating
a new account two public keys need to be provided by the caller and registered in the Argennon smart contract.
One public key will be used for issuing digital signatures, and the other one will be used for voting. The
provided public keys need to meet certain cryptographic requirements,\footnote{Argennon uses Prove
Knowledge of the Secret Key (KOSK) scheme.} and can not be already registered in the system.

If the owner of the new account is an application, the \texttt{applicationID} of the owner will be registered in the
ARG smart contract and no public keys are needed. An application can own an arbitrary number of accounts.

\note{Explicit key registration enables Argennon to decouple cryptography from the blockchain design. In this way,
    if the cryptographic algorithms used become insecure for some reason, for example because
    of the introduction of quantum computers, they could be easily upgraded.}


\section{Transactions}\label{sec:transactions}

Every Argennon transaction consists of two \texttt{i\_invoke\_dispatcher} instructions, the first instruction always
transfers the proposed fee of the transaction in ARGs from a sender account to the fee sink accounts, and
the second performs the requested operation. If the first instruction fails, the transaction will not be added to
the Argennon blockchain.

Users interact with AVM smart contracts using
the second \texttt{i\_invoke\_dispatcher} instruction of a transaction.
Transferring all assets, including ARG, is done by that instruction.

The \texttt{i\_invoke\_dispatcher} instruction invokes the \texttt{dispatcher} method of a smart contract. Every AVM
smart contract has a \texttt{dispatcher} method, and the Argennon protocol requires
the \texttt{dispatcher} method to accept an HTTP request as its argument and
return an HTTP response.

As a result, every Argennon transaction contains two HTTP requests. In addition to these HTTP requests, the
transaction is required to contain a resource declaration object, specifying the maximum amount of resources
it needs for execution.

\note{Argennon smart contracts use HTTP as the application protocol and they are advised to have a RESTful API design.}

\subsection{Resource Declaration}\label{subsec:resource-declaration}

Every Argennon transaction is required to specify a cap for all the resources it needs. This
includes memory, network and processor related resources. When a transaction reaches one of its
pre-declared resource caps, executing any AVM instruction which uses that resource, will result in an AVM exception.

As we know, every Argennon transaction consists of two \texttt{i\_invoke\_dipatcher} instructions. The first
instruction is always considered as a \emph{free} instruction and resources spent during its execution
session will not be counted. As a result, only the second instruction could fail due to exceeding resource limits.

The Argennon protocol defines an execution cost for
every AVM instruction, reflecting the amount of resources its emulation needs. Every
transaction is required to specify two maximum execution costs: \texttt{maxInternalCost}
and \texttt{maxExternalCost}. The \emph{external} execution cost of a transaction is the \textbf{overall} cost of its
\texttt{invoke\_dispatcher} and \texttt{invoke\_later} instructions,\footnote{By overall cost, we mean the execution
cost needed for reaching the next instruction.} and the remaining execution cost will be considered as
the \emph{internal} cost. If a transaction reaches one of its maximum costs, executing any instruction which has
that type of cost, will throw an AVM exception.

\note{When a transaction reaches its \texttt{maxExternalCost}, it can still keep executing
its own code, while it can not call other smart contracts.
This way the execution cost of a smart contract is completely decoupled from the
smart contract it calls, and a malicious contract can not make its invoker fail unconditionally
by using infinite loops.}

Also, Argennon transactions are required to specify what heap or code area addresses they will access. This will
enable validators to parallelize transaction validation as we will see in Section~\ref{sec:concurrency}. A transaction
that tries to access a memory location that is not in its access list, will be rejected.
Users could use off-chain \emph{smart contract oracles} to predict the list of memory locations their transactions need.

A smart contract oracle is a full AVM emulator that keeps a full local copy of the AVM storage and can emulate AVM
execution without accessing a ZK-EDB server. Smart contract oracles can be used for reporting useful information about
Argennon transactions such as accessed AVM heap or code area locations, exact amount of execution cost,
and so on.

Every Argennon transaction is required to provide the following information as an upper bound for the
resources it needs:

\begin{itemize}
    \item Maximum internal execution cost
    \item Maximum external execution cost
    \item A list of heap/code-area locations for reading
    \item A list of heap locations for writing
    \item A list of heap chunks it will deallocate (if any)
    \item A list of methods it will delete (if any)
    \item Number and size of heap chunks it will allocate (if any)
    \item Number and size of method bytecodes it will allocate (if any)
\end{itemize}

If a transaction tries to violate any of these predefined limitations, it will be considered failed, and the network
can receive the proposed fee of that transaction.

\subsection{Authorization}\label{subsec:txn-auth}

Argennon transactions do not have a sender. The authorization of the requested operation is always done by checking the
digital signatures that are provided as a part of the HTTP request to the \texttt{dispatcher} method.

While every block of the Argennon blockchain stores the commitment of the transaction list, Argennon does not enforce
storage of the transaction history. To be able to detect replay attacks, we require
every signature that a user creates to have a nonce. This nonce consists of the issuance round of the signature
and a sequence number: \texttt{(issuance,\ sequence)}. When a user creates more than one signature in a round, he
must sequence his signatures starting from 0 (i.e.~the sequence number restarts from 0 in every round). We define
a maximum lifetime for signatures, so a signature is invalid if \texttt{currentRound - issuance > maxLifeTime} or
if a signature of the same user with a bigger or equal nonce is already used
(i.e.~is recorded in the blockchain). A nonce is bigger than another nonce if it has an older issuance. If two
nonces have an equal issuance, the nonce with the bigger sequence number will be considered bigger.

To be able to detect invalid signatures, we keep the maximum nonce of used digital signatures per user. This information
is stored in the ARG smart contract and when the difference between \texttt{issuance} component of the nonce and
the current round becomes bigger than the maximum allowed lifetime of a signature, it can be safely
deleted.\footnote{in some conventional
blockchains, the nonce data can never be deleted, even if the account has zero balance and is no longer used.}


\begin{lstlisting}[language=python, frame=TB, float, title=An Argennon transaction in YAML format,label={lst:txn-example}]
---
fee: |
    PUT /balances/0x73.0xa2?to=fee&amount=0.26&sig=5b73CbmwQNRC7fWUY15 HTTP/1.1
call: |
    POST httpb://bac.argennon.net/54.189.21/proposals HTTP/1.1
    Content-Type: application/json; charset=utf-8
    Content-Length: 69

    {
        "name": "Grant Proposal",
        "recipient": "0x24.0x8f.0x29.0xa1",
        "amount": 25000,
        "sig"= "2a36Gtrw249wQCD70nWY49d"
    }
caps:
    internal: 2500000 # maximum number of AVM execution clocks
    external: 1000000
    read: [(2654,3),(15642,0),(15642,1),(15642,3)]
    write: [(15642,0),(20154,0),(20154,1)]
\end{lstlisting}

\subsection{Transaction Fee}\label{subsec:fee}

Every Argennon transaction is required to pay two types of fees: execution fee, which is paid for executing the
transaction, and storage fee, which is paid for the amount of storage the transaction allocates.

A transaction pays
its fees by providing digital signatures of one or more accounts, authorizing the transfer of the amount of fee in
ARG from one or more accounts to the fee sink accounts, and the fee is transferred by the first
\texttt{i\_invoke\_dispatcher} instruction of the transaction.

\note{An Argennon transaction always pays all of its proposed fee, no matter how much of its predefined resources
were not used in the final emulation. This will incentivize users to report the resource usage of their
transactions more accurately.}

