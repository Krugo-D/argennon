%! Author = aybehrouz


\section{Applications}\label{sec:applications}

An Argennon application or a smart contract is a collection of method bytecodes and heap chunks that are stored in
the AVM storage, identified by a unique application identifier. An application identifier, \texttt{applicationID}, is
a unique prefix code generated by the \emph{applications} prefix tree. (See Section~\ref{sec:identifiers}.)

An application identifier can
be considered as the address of an application and has the following standard symbolic representation:
\begin{verbatim}
<application-id> ::= "["<hex-prefix-code>"]"
<hex-prefix-code> ::= "0x"<hex-num>"."<hex-prefix-code> | "0x"<hex-num>
\end{verbatim}
where \texttt{<hex-num>} is a hexadecimal number between $0$ and $255$, using lower case
letters \texttt{[a-f]} for showing digits greater than $9$.

For example \texttt{[0x24.0xff.0xda]}, \texttt{[0x0]} and \texttt{[0x3.0xa0.0x0.0x0]}, are valid application addresses.

Argennon has two special smart contracts: the \emph{root} smart contract\footnote{also called the root app} and
the \emph{ARG} smart contract\footnote{also called the Argennon smart contract or the Argennon app.}.
The root smart contract, with \texttt{applicationID=[0x0]}, is a privileged smart contract responsible for
method invocation and installation/uninstallation of other smart contracts.
On the other hand, the ARG smart contract, with \texttt{applicationID=[0x1]}, controls the ARG token, the main
currency of the Argennon blockchain, and also manages a database of public keys and handles signature verification.

Both of these smart contracts are mutable smart contracts and can be updated by the Argennon governance protocol.


\section{Accounts}\label{sec:accounts}

Argennon accounts are entities defined inside the ARG smart contract.
Every Argennon account is uniquely identified by a prefix code generated using \emph{accounts} prefix tree. An account
identifier can be considered as the address of an account and has the following standard symbolic representation:
\begin{verbatim}
<account-id> ::= "["<decimal-prefix-code>"]"
<decimal-prefix-code> ::= <dec-num>"."<decimal-prefix-code> | <dec-num>
\end{verbatim}
where \texttt{<dec-num>} is a normal decimal number between $0$ and $255$.

For example \texttt{[21.255.37]}, \texttt{[0]} and \texttt{[1.0.0.0.0]}, are valid standard symbolic representations
of account addresses.

A new account can be created by invoking \texttt{createAccount} method from the Argennon smart contract. For creating
a new account two public keys need to be provided by the caller and registered in the Argennon smart contract.
One public key will be used for issuing digital signatures, and the other one will be used for voting. The
provided public keys need to meet certain cryptographic requirements,\footnote{Argennon uses Prove
Knowledge of the Secret Key (KOSK) scheme.} and can not be already registered in the system.

If the owner of the new account is an application, the \texttt{applicationID} of the owner will be registered in the
ARG smart contract and no public keys are needed. An application can own an arbitrary number of accounts.


\section{Transactions}\label{sec:transactions}

Every Argennon transaction is a single \texttt{invoke\_external} instruction which calls a method from the Argennon
root smart contract. This method always transfers the proposed fee of the transaction in ARGs from a
sender account to the fee sink accounts and then performs the requested operation. The Argennon root smart contract
has four public methods:

\begin{itemize}
    \item \texttt{avmCall}: invokes a method from an
    AVM smart contract. Users interact with AVM smart contracts using these transactions. Transferring all
    assets, including ARGs, is done by these transactions.
    \item \texttt{installApp}: installs an AVM smart contract and determines the update policy of the smart
    contract: if the contract is updatable or not, which accounts can update or uninstall the contract, and so
    on.
    \item \texttt{unInstallApp}: removes an AVM smart contract.
    \item \texttt{updateApp}: updates an AVM smart contract (if allowed).
\end{itemize}

Argennon transactions do not have a sender. The authorization of the requested operation is always done by checking the
digital signatures that are provided as a part of the argument list to the root smart contract method.

Every Argennon transaction is required to specify a cap for all the resources it needs. This
will include memory, network and processor related resources. The protocol defines an execution cost for
every AVM instruction, reflecting the amount of resources its emulation needs, and every transaction is required
to specify a maximum execution cost. If during emulation, a transaction reaches this maximum cost, it will be
considered failed and the network can receive the proposed fee of that transaction.

Also, Argennon transactions are required to specify what heap or code area addresses they will access. This will
enable validators to parallelize transaction validation as we will see in Section~\ref{sec:concurrency}. A transaction
that tries to access a memory location that is not in its access lists, will be rejected.
Users could use off-chain \emph{smart contract oracles} to predict the list of memory locations their transactions need.

A smart contract oracle is a full AVM emulator that keeps a full local copy of the AVM memory and can emulate AVM
execution without accessing a ZK-EDB server. Smart contract oracles can be used for reporting useful information about
Argennon transactions such as accessed AVM heap or code area locations, exact amount of execution cost,
and so on.

Every Argennon transaction is required to provide the following information as an upper bound for the
resources it needs:

\begin{itemize}
    \item Maximum execution cost
    \item A list of heap/code-area locations for reading
    \item A list of heap locations for writing
    \item A list of heap chunks it will deallocate
    \item A list of methods it will delete (if any)
    \item Number and size of heap chunks it will allocate
    \item Number and size of method bytecodes it will allocate (if any)
\end{itemize}

If a transaction tries to violate any of these predefined limitations, it will be considered failed, and the network
can receive the proposed fee of that transaction.

\note{An Argennon transaction always pays all of its proposed fee, no matter how much of its predefined resources
were not used in the final emulation. This will incentivize users to exactly report their
transactions resource usage.}


\section{Blocks}\label{sec:blocks}

The Argennon blockchain is a sequence of blocks. Every block represents an ordered list of transactions, intended to be
executed by the Argennon Virtual Machine. The first block of the blockchain, the \emph{genesis} block, is a spacial
block that fully describes the initial state of the AVM. Every block of the Argennon blockchain thus corresponds to a
unique AVM state which can be calculated deterministically from the genesis block.

A block of the Argennon blockchain contains the following information:

\begin{center}
    \begin{tabular}{||c||}
        \hline
        \textbf{Block} \\ [0.5ex]
        \hline\hline
        commitment to the staking database            \\ [1.2ex]
        commitment to the method database             \\ [1.2ex]
        commitment to the heap database               \\ [1.2ex]
        commitment to the set of transactions         \\ [1.2ex]
        last block certificate issued by         \\
        the validators committee                      \\ [1.2ex]
        clustering directives                         \\ [1.2ex]
        random seed                                   \\ [1.2ex]
        previous block hash                           \\ [1.2ex]
        \hline
    \end{tabular}
\end{center}

\subsection{Block Validation}\label{subsec:block-validation}

Having the previous AVM state, the transaction list and the clustering directives of a block, a node can calculate
commitments to the staking, method and heap databases of the current block by emulating the AVM execution. If the
node can obtain the previous block information from a trusted source, it does not need to have a trusted local
copy of the AVM state,
and it can reliably retrieve the required storage pages from a ZK-EDB server. We call this type of block verification
\emph{conditional} block validation. This validation is conditional because the validity of the current block is
conditioned on the validity of the previous block.

Interestingly, conditional block validation of multiple blocks can be done in parallel. If a node has enough bandwidth
and computational resources, it can conditionally verify any number of blocks from a previously created blockchain
simultaneously and in parallel. As we will see in Section~\ref{subsec:validators-committee}, this property plays an
important role in the Argennon consensus protocol.

To some extent, conditional validation of a single block could be parallelized as well. Many transactions
in a block are actually independent and the order of their execution does not
matter. These transactions can be safely validated in parallel. Section~\ref{sec:concurrency} further
develops this concept.


\subsection{Block Certificate}\label{subsec:block-certificate}

An Argennon block certificate is an aggregate signature of some predefined subset of accounts. This predefined subset
is called the certificate committee and their signature ensures that the certified block is conditionally
valid given the validity of some previous block.

Argennon uses BLS aggregate signatures to represent block certificates. To better understand block certificates and
the Argennon consensus protocol, we need to briefly review the BLS signature scheme and its aggregation mechanism.

The BLS signature scheme operates in a prime order group and supports simple threshold signature generation,
threshold key generation, and signature aggregation. To review, the scheme uses the following ingredients:

\newcommand{\G}{\mathbb{G}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\adv}{{\cal A}}
\newcommand{\bdv}{{\cal B}}
\newcommand{\deq}{\mathrel{\mathop:}=}
\newcommand{\SK}{\mathit{sk}}
\newcommand{\PK}{\mathit{pk}}
\newcommand{\C}{\mathit{cert}}
\newcommand{\APK}{\mathit{apk}}
\newcommand{\DPK}{\mathit{\Delta pk}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\xwedge}{\, \operatorname{\text{$\wedge$}}\, }
\newcommand{\abs}[1]{\lvert #1 \rvert}
\newcommand{\Hm}{H_0}
\newcommand{\Hpk}{H_1}
\newcommand{\qHpk}{Q_{\Hpk}}
\newcommand{\qHm}{Q_{\Hm}}
\newcommand{\qsig}{Q_{\text{sig}}}

\begin{itemize}
    \item An efficiently computable \emph{non-degenerate} pairing $e:\G_0 \times \G_1 \to \G_T$
    in groups $\G_0$, $\G_1$ and $\G_T$ of prime order $q$. We let $g_0$ and $g_1$ be generators
    of $\G_0$ and $\G_1$ respectively.
    \item A hash function $H_0: \mathcal{M} \rightarrow \mathbb{G}_0$, where $\mathcal{M}$ is the message space.
    The hash function will be treated as a random oracle.
\end{itemize}

The BLS signature scheme is defined as follows:

\begin{itemize}
    \item $\textbf{KeyGen}()$: choose a random $\alpha$ from $\Z_q$ and set $h \gets g_1^\alpha \in \G_1$.
    output $\PK \deq (h)$ and $\SK \deq (\alpha)$.
    \item $\textbf{Sign}(\SK, m)$: output $\sigma \gets \Hm(m)^\alpha \in \G_0$.
    The signature $\sigma$ is a \emph{single} group element.
    \item $\textbf{Verify}(\PK,m,\sigma)$: if $e(g_1, \sigma) = e\big(\PK,\ \Hm(m)\big)$  then output "accept",
    otherwise output "reject".
\end{itemize}

Given triples $(\PK_i,\ m_i,\ \sigma_i)$ for $i=1,\ldots,n$,
anyone can aggregate the signatures $\sigma_1,\ldots,\sigma_n \in \G_0$
into a short convincing aggregate signature $\sigma$ by computing
\begin{equation}
    \label{eq:agg}
    \sigma \gets \sigma_1 \cdots \sigma_n \in \G_0.
\end{equation}
Verifying an aggregate signature $\sigma \in \G_0$ is done by checking that
\begin{equation}
    \label{eq:aggdiff}
    e(g_1, \sigma) = e\big(\PK_1,\ \Hm(m_1)\big) \cdots e\big(\PK_n,\ \Hm(m_n)\big).
\end{equation}
When all the messages are the same ($m = m_1 = \ldots = m_n$), the verification relation~\eqref{eq:aggdiff} reduces to
a simpler test that requires only two pairings:
\begin{equation}
    \label{eq:aggsame}
    e(g_1, \sigma) = e\Big(\PK_1 \cdots \PK_n,\ \Hm(m)\Big).
\end{equation}
We call $\APK=\PK_1 \cdots \PK_n$ the aggregate public key.

To defend against \emph{rogue public key} attacks, Argennon uses Prove Knowledge of the Secret Key (KOSK) scheme. As we
explained in Section~\ref{sec:accounts}, when an account is created its public keys need to be registered in
the ARG smart contract. Therefore, the KOSK scheme can be easily implemented in Argennon.

Because it is not usually possible to collect the signatures of all members of a certificate committee, an Argennon
block certificate essentially is an Accountable-Subgroup Multi-signature (ASM). Argennon uses a simple ASM scheme
based on BLS aggregate signatures.

Argennon block certificates constitute an ordered sequence based on the order of blocks they certify. If we show
the certificate of committee $C$ for the $i$-th block\footnote{note that the $i$-th block certificate is not
necessarily the certificate of the $i$-th block.} with $\C_i$, and the set of signers
with $S_i$, then the block certificate $\C_i$ can be considered as a tuple:
\begin{equation}
    \C_i=(\sigma_i,\ C-S_{i})\label{eq:cert},
\end{equation}
where $\sigma_i$ is the aggregate signature issued by $S_i$.

The aggregate public key of the certificate can
be calculated from:
\begin{equation}
    \APK_i=\APK_C\APK_{C-S_i}^{-1}\label{eq:aggCertPK}\ ,
\end{equation}
where $\APK_{A}$ shows the aggregate public key of all accounts in $A$.

Alternately we can use $\APK_{i-1}$ to calculate the aggregate public key:
\begin{equation}
    \APK_i=\APK_{i-1}\APK_{S_i-S_{i-1}}\APK_{S_{i-1}-S_i}^{-1}\ .\label{eq:aggPK-2}
\end{equation}

When an Argennon account is created, both its $\PK$ and $\PK^{-1}$ is registered in the ARG smart contract, so the
inverse of any aggregate public key can be easily computed.\footnote{since the group operator of a cyclic
group is commutative, we have $(ab)^{-1}=a^{-1}b^{-1}$.}

\section{Consensus}\label{sec:consensus}
\input{sections/consensus}

\section{Incentive mechanism}\label{sec:incentive-mechanism}

\note{TODO: update this section!}

\subsection{Transaction Fee}\label{subsec:transaction-fee}

Every transaction in the Argennon blockchain starts with an \texttt{invoke\_external} instruction which calls a
special method from the root smart contract. This method will transfer the proposed fee of the transaction in ARGs
from a sender account to the fee sink accounts. Argennon has two fee sink accounts: \texttt{execFeeSink} collects
execution fees and \texttt{dbFeeSink} collects fees for ZK-EDB servers. The Protocol decides how to distribute the
transaction fee between these two fee sink accounts.

When a block is added to the blockchain, the proposer of that block will receive a share of the block fees.
Consequently, a block proposer is always incentivized to include more transactions in his block. However, if he
puts too many transactions in his block and the validation of the block becomes too difficult, some validators
may not be able to validate all transactions on time. If a validator can not validate a block in the required
time, he will consider the block invalid. So, when a proposed block contains too many transactions, the network
may reach consensus on another block, and the proposer of that block will not receive any fees. As a result, a
proposer is incentivized to use network transaction capacity optimally.

On the other hand, we believe that the proposer does not have enough incentives for optimizing the storage size
of the transaction set. Therefore, we require that \textbf{the size of the transaction set of every block in
bytes be lower than a certain threshold.}

Validators need to spend resources for validating transactions. When a validator starts the emulation of the AVM
to validate a transaction, solely from the code he can't predict the time the execution will finish. This will
give an adversary an opportunity to attack the network by broadcasting transactions that never ends. Since,
validators can not finish the execution of these transactions, the network will not be able to charge the
attacker any fees, and he would be able to waste validators resources for free.

To mitigate this problem, we require that every transaction specify a cap for all the resources it needs. This
will include memory, network and processor related resources. Also, the protocol defines an execution cost for
every AVM instruction reflecting the amount of resources its emulation needs. This will define a standard way for
measuring the execution cost of any \texttt{avmCall} transaction. Every \texttt{avmCall} transaction is required
to specify a maximum execution cost. If during emulation it reaches this maximum cost, the transaction will be
considered failed and the network can receive the proposed fee of that transaction.


\subsection{Incentives for ZK-EDB Servers}\label{subsec:zk-edb-servers}

The incentive mechanism for ZK-EDB servers should have the following properties:

\begin{itemize}
    \item It incentivizes storing all memory blocks, whether a heap page or a code area block, and not only those
    which are used more frequently.
    \item It incentivizes ZK-EDB servers to actively provide the required memory blocks for validators.
    \item Making more accounts will not provide any advantages for a ZK-EDB server.
\end{itemize}

For our incentive mechanism, we require that every time a validator receives a memory block from a ZK-EDB, after
validating the data, he give a receipt to the ZK-EDB. In this receipt the validator signs the following information:

\begin{itemize}
    \item \texttt{ownerAddr}: the ARG address of the ZK-EDB\@.
    \item \texttt{receivedBlockID}: the ID of the received memory block.
    \item \texttt{round}: the current round number.
\end{itemize}

\note{In a round, an honest validator never gives a receipt for an identical memory block to two different ZK-EDBs.}

To incentivize ZK-EDB servers, a lottery will be held every round and a predefined amount of ARGs from
\texttt{dbFeeSink} account will be distributed between winners as a prize. This prize will be divided equally
between all \emph{winning tickets} of the lottery.

\note{One ZK-EDB server could own multiple winning tickets in a round.}

To run this lottery, every round, based on the current block seed, a collection of \emph{valid} receipts will be
selected randomly as the \emph{winning receipts} of the round. A receipt is \emph{valid} in round $r$ if:

\begin{itemize}
    \item The signer was a validator in the round $r - 1$ and voted for the agreed-upon block.
    \item The data block in the receipt was needed for validating the \textbf{previous} block.
    \item The receipt round number is $r - 1$.
    \item The signer did not sign a receipt for the same data block for two different ZK-EDBs in the previous round.
\end{itemize}
For selecting the winning receipts we could use a random generator:
\begin{verbatim}
IF random(seed|validatorPK|receivedBlockID) < winProbability THEN
    the receipt issued by validatorPK for receivedBlockID is a winner
\end{verbatim}
\begin{itemize}
    \item \texttt{random()} produces uniform random numbers between 0 and 1, using its input argument as a seed.
    \item \texttt{validatorPK} is the public key of the signer of the receipt.
    \item \texttt{receivedBlockID} is the ID of the memory block that the receipt was issued for.
    \item \texttt{winProbability} is the probability of winning in every round.
    \item \texttt{seed} is the current block seed.
    \item \texttt{|} is a concatenation operator.
\end{itemize}

\note{The winners of the lottery were validators one round before the lottery round.}

Also, based on the current block seed, a random memory block, whether a heap page or a code area block, is
selected as the challenge of the round. A ZK-EDB that owns a winning receipt needs to broadcast a \emph{winning
ticket} to claim his prize. The winning ticket consists of a winning receipt and a \emph{solution} to the round
challenge. Solving a round challenge requires the content of the memory block which was selected as the round
challenge. This will encourage ZK-EDBs to store all memory blocks.

A possible choice for the challenge solution could be the cryptographic hash of the content of the challenge
memory block combined with the ZK-EDB ARG address: \texttt{hash(challenge.content|ownerAddr)}

The winning tickets of the lottery of round $r$ need to be included in the block of the round $r$,
otherwise they will be considered expired. Validation and prize distribution for the winning tickets of round
$r$ will be done in the round $r + 1$. This way, \textbf{the content of the challenge memory block could be
kept secret during the lottery round.} Every winning ticket will get an equal share of the lottery prize.

\subsection{Memory Allocation and De-allocation Fee}\label{subsec:memory-allocation-and-de-allocation}

Every $k$ round the protocol chooses a price per byte for AVM memory. When a smart contract executes a heap
allocation instruction, the protocol will automatically deduce the cost of the allocated memory from the ARG
address of the smart contract.

To determine the price of AVM memory, Every $k$ round, the protocol calculates \texttt{dbFee} and
\texttt{memTraffic} values. \texttt{dbFee} is the aggregate amount of collected database fees, and
\texttt{memTraffic} is the total memory traffic of the system. For calculating the memory traffic of the system
the protocol considers the total size of all the memory pages that were accessed for either reading or writing
during a time period. These two values will be calculated for the last $k$ rounds and the price per byte of
AVM memory will be a linear function of \texttt{dbFee/memTraffic}

When a smart contract executes a heap de-allocation instruction, the protocol will refund the cost of
de-allocated memory to the smart contract. Here, the current price of AVM memory does not matter and the protocol
calculates the refunded amount based on the average price the smart contract had paid for that allocated memory.
This will prevent smart contracts from profit taking by trading memory with the protocol.


\section{Governance}\label{sec:governance}

The Argennon Decentralized Autonomous Governance system (ADAGs)
\note{not yet written...}


\section{Concurrency}\label{sec:concurrency}
\input{sections/concurrency}
